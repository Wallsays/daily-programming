// Array — массив
// Boolean — логическое значение
// Function — функция
// Number — число
// Object — хэш
// RegExp — регулярное выражение
// String — строка

var a = [];     // Эквивалентно var a = new Array();
var a = {};     // Эквивалентно var a = new Object();
var a = function () {} // Эквивалентно var a = new Function();
var a = /(?:)/; // Эквивалентно var a = new RegExp(); В данном примере я написал (?:), что соответствует пустому регулярному выражению, т.к. запись // создаёт комментарий

var a = {}; // Создали новый объект. Он может быть любым.
a.x = 0;    // Записали свойство 'x' объекту 'a'.
a['f'] = 0; // А можно и так

Array.prototype.a = function () {
  return this;
}
[].a(); // Вернёт пустой массив

var a = {
  x: 0,
  c: 0,
  d: 0
}
 
function a(x) {
  return [this, x]; // Возвращаем массив значений. this равен window, x — первому аргументу функции.
}
a(1);   // window, 1
a(1)[0] // window
a(1)[1] // 1


alert(e); // Всё ОК.
function e() {}

alert(f); // ReferenceError
f = function () {}

// ============================================

var a = 'Hello, world!'; // Эквивалентно var a = "Hello, world!"
var a = 'Hello, \'world!\'';

'Hello, world'.replace('He', 'Ax'); // Axllo, world!
'Hello, world!'.charAt(2); // l
'Hello, world!'.substr(0, 2); // Hel
'Hello, world!'.split('o'); // [Hell', ', w', 'rld!'];

'Hello, world!'.slice(-2); // 'd!'
'Hello, world!'.slice(-4, -2); // 'rl'
'Hello, world!'.indexOf('H'); // 0

var num = 5; // equal var num = new Number(5);

// parseInt(o, n) — представить объект как число. Если это невозможно, то возвращает NaN. n — основание системы счисления.
parseInt('100'); // 100 как число

(15).toString(16); // 'F'

// sin, cos, tan, asin, acos, atan, atan2, log — вычислить значение математических функций для числа
// ceil — округлить число в большую сторону
// floor — округлить число
// round — округлить число в меньшую сторону
// min, max — возвращает минимальное/максимальное число среди списка аргументов
// abs — модуль числа
// random — случайное число от 0 до 1

Math.ceil(3.25); // 4
Math.abs(-1); // 1
Math.random(); // 0.25200970509109777

0xF; // 15, префикс 0x для 16-ричных чисел
09; // 10, префикс 0 для 8-ричных чисел


(177).toString(16);      // 177 -> into 0x format
'JavaScript'.slice(-2);  // 'pt'

// ============================================

// array.push — добавить элемент в конец массива.
[].push(0); // Массив станет таким: [0]

// array.pop — удалить последний элемент массива.
[0, 1, 2].pop(); // [0, 1]

// array.shift — добавить элемент в начало массива
[0].shift(1); // [1, 0]

// array.unshift — удалить первый элемент массива

[0, 1].unshift(); // [1]

// array.sort — сортировать содержимое массива в алфавитном порядке
['a', 'c', 'b'].sort(); // ['a', 'b', 'c']

// array.slice — аналогичен методу string.slice, но работает не с символами строки, а с элементами массива
[0, 1, 2, 3].slice(-2); // [2, 3]

// array.reverse — перевернуть содержимое массива
[0, 1].reverse(); // [1, 0]

// array.join — склеить содержимое массива в строку по разделителю, указанному в первом аргументе
[0, 1].join('a'); // 0a1

// =============================================

// В прототипе объекта Function также есть два встроенных метода: это apply и call. Они оба вызывают функцию в нужном вам контексте, передавая ей this, указанный в первом аргументе. Список передаваемых функции аргументов apply принимает вторым аргументом в виде массива, а call принимает список аргументов.
function myfunc(a) {
  return [this, a];
}
myfunc.apply(0, [1]); // [0, 1]
myfunc.call(0, 1);    // [0, 1]

Math.max.apply(window, [0, 1, 2, 3]);

function myfunc(a) {
  return arguments[0];
}
myfunc('x'); // x

// arguments имеет свойство length (количество аргументов минус один) и callee (исходный код вызываемой функции).

// Вызов функции myfunc в контексте объекта 'a', передав ей массив аргументов [0, 1].
myfunc.apply(a, [0, 1]);

// ссылкa на встроенный метод call
Function.prototype.call;

// функцию, которая возвратит свой исходный код (в народе это называется quine).
(function () {
  return arguments.callee;
})();

// =============================================

// <\w+(?:\s\w+=(?:'|")?.+(?:'|")?)(?:\s\/>|>.?<\/\w+>)

var a = new RegExp('a?x|d', 'gi');
// equals
var a = /a?x|d/gi
// Первым аргументом RegExp принимает само регулярное выражение, а вторым — спец-флаги. Их три: g соответствует глобальному поиску (без этого флага будет найдено только первое совпадение), i соответствует игнорированию регистра, m — многострочному поиску.

// \ — делает мета-символ обычным символом и наоборот. Это называется экранирование.
// ^ — соответсвует началу строки. А, например, \^ соответствует символу ^.
// $ — соответсвует концу строки
// * — соответствует повторению символа 0 или более раз. Аналогично ?+.
// + — соответсвует повторению символа 1 и более раз.
// ? — соответсвует повторению символа 0 или 1 раз.
// \w — соответствует любому латинскому символу
// . — найдёт любой символ, кроме перевода строки
// \d — найдёт любую цифру
// (x) — запоминающие скобки. Внутри регулярного выражения к содержимому скобок можно обращаться так: \N, где N — номер скобок. Функция string.replace во второй аргумент передаёт спец-символ $N, где N — номер скобки, по которому можно найти содержимое скобок.

// Внутри скобок действуют следующие мета-символы:
// ?:x — отменяет "запоминание"
// x(?=y) — реализует "заглядывание вперёд". Найдёт 'x', только если за ним следует 'y'
// x(?!y) — найдёт 'x', если за ним не следует 'y'
// x|y — найдёт 'x' или 'y'
// x{n} — найдёт 'x', если он повторяется 'n' раз
// x{,n} — найдёт 'x', если он повторяется <n раз
// x{n,} — найдёт 'x', если он повторяется >n раз
// x{n,z} — найдёт 'x', если он повторяется от 'n' до 'z' раз
